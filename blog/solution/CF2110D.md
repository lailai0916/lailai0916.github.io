---
title: 'CF2110D Fewer Batteries'
date: 2025-10-27T16:23
authors: lailai
tags: [solution, codeforces]
---

<Solution pid="CF2110D" aid="sbizdffq" />

<!-- truncate -->

## 题意简述

给定一张 $n$ 个点和 $m$ 条边的有向无环图（DAG），保证每条边 $u<v$。每个顶点有权值 $a_i$，每条边有权值 $w_i$。

一个机器人从节点 $1$ 出发，初始电量为 $0$。机器人在到达第 $i$ 个顶点时可以增加 $[0,a_i]$ 的电量，通过第 $j$ 条边时电量必须不小于 $w_j$。求机器人到达节点 $n$ 时的最小电量。

## 解题思路

答案具有单调性，可以二分。设当前答案为 $x$，考虑判断是否可以到达。

由于电量不会减少，所以全程电量不能超过 $x$，而且显然越早提高电量越好。

设 $f_i$ 表示到达节点 $i$ 时的最大电量。由于 $u<v$，所以可以直接遍历 $v\in[1,n]$。

考虑计算 $f_v$，从所有入边能获得的最大电量为：

$$
t=\max_{w(u,v)\le f_u}f_u
$$

加上当前节点能获得的最大电量 $a_v$，且电量不能超过 $x$，所以转移式为：

$$
f_v=\min(t+a_v,x)
$$

如果不可到达就将 $f_v$ 设置为 $-\infty$，最终判断是否满足 $f_n\ge 0$ 即可。

## 参考代码

```cpp
#include <bits/stdc++.h>
using namespace std;

using ll=long long;
const int inf=0x3f3f3f3f3f3f3f3f;
const int N=200005;
vector<pair<int,int>> G[N];
ll a[N],f[N];
bool check(ll x,int n)
{
	f[1]=min(a[1],x);
	for(int v=2;v<=n;v++)
	{
		f[v]=-inf;
		for(auto [u,w]:G[v])
		{
			if(w<=f[u])f[v]=max(f[v],f[u]);
		}
		f[v]=min(f[v]+a[v],x);
	}
	return f[n]>=0;
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	int T;
	cin>>T;
	while(T--)
	{
		int n,m;
		cin>>n>>m;
		ll sum=0;
		for(int i=1;i<=n;i++)
		{
			cin>>a[i];
			sum+=a[i];
		}
		while(m--)
		{
			int u,v,w;
			cin>>u>>v>>w;
			G[v].push_back({u,w});
			sum+=w;
		}
		ll l=0,r=sum+1;
		while(l<r)
		{
			ll mid=l+r>>1;
			if(check(mid,n))r=mid;
			else l=mid+1;
		}
		cout<<(l!=sum+1?l:-1)<<'\n';
		for(int i=1;i<=n;i++)G[i].clear();
	}
	return 0;
}
```
