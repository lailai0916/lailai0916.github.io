---
title: 'P9408 『STA - R2』Locked'
date: 2023-06-11T15:54
authors: lailai
tags: [solution, luogu]
---

<Solution pid="P9408" aid="yjr0wy9o" />

<!-- truncate -->

## 解题思路

设 $f(x,y)$ 为将 $x$ 变成 $y$ 的拨动次数，不难写出 $f(x,y)$ 的通式：

$$
f(x,y)=\min(\lvert(x-y+10)\bmod 10\rvert,\lvert(y-x+10)\bmod 10\rvert)
$$

考虑使用 DP 解决：设 $g_{i,j}$ 表示前 $i$ 个位置单调不减且以 $j$ 结尾的序列最小拨动次数。

显然前一项不能比后一项大，所以后一项只能由小于等于前一项的结果中取最小值，得出 DP 递推方程：

$$
g_{i,j}=\min_{k=1}^j g_{i-1,k}+f(a_i,j)
$$

同理，设 $h_{i,j}$ 表示后 $i$ 个位置单调不减且以 $j$ 开头的序列最小拨动次数，得出 DP 递推方程：

$$
h_{i,j}=\min_{k=1}^j g_{i+1,k}+f(a_i,j)
$$

枚举所有的 $i,j$，表示以 $i$ 为峰顶，以 $j$ 为峰值的拨动次数，峰顶会被重复计算 $1$ 次，所以要减去 $f(a_i,j)$ 再取最小值，答案为：

$$
\min_{i=1}^n \min_{j=0}^9 g_{i,j}+h_{i,j}-f(a_i,j)
$$

## 参考代码

```cpp
#include <bits/stdc++.h>
using namespace std;

const int inf=0x3f3f3f3f;
const int N=5000005;
int a[N],g[N][10],h[N][10];
int f(int x,int y)
{
	return min(abs((x-y+10)%10),abs((y-x+10)%10));
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=0;j<10;j++)
		{
			g[i][j]=inf;
			h[i][j]=inf;
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=0;j<10;j++)
		{
			for(int k=0;k<=j;k++)
			{
				g[i][j]=min(g[i][j],g[i-1][k]+min(abs((a[i]-j+10)%10),abs((j-a[i]+10)%10)));
			}
		}
	}
	for(int i=n;i>=1;i--)
	{
		for(int j=0;j<10;j++)
		{
			for(int k=0;k<=j;k++)
			{
				h[i][j]=min(h[i][j],h[i+1][k]+min(abs((a[i]-j+10)%10),abs((j-a[i]+10)%10)));
			}
		}
	}
	int ans=inf;
	for(int i=1;i<=n;i++)
	{
		for(int j=0;j<10;j++)
		{
			ans=min(ans,g[i][j]+h[i][j]-min(abs((a[i]-j+10)%10),abs((j-a[i]+10)%10)));
		}
	}
	cout<<ans<<'\n';
	return 0;
}
```
